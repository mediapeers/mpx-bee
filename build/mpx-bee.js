// Generated by CoffeeScript 1.12.5
(function() {
  var AWS, BACKUP_PREFIX, MIM, Promise, SWITCHES, TMPDIR, _, archiver, backupFiles, clearFiles, createZip, fs, glob, optparse, opts, path, printLine, printWarn, readExistingFiles, readFiles, s3, uploadFiles, util;

  _ = require('lodash');

  archiver = require('archiver');

  AWS = require('aws-promised');

  optparse = require('optparse');

  util = require('util');

  fs = require('fs');

  glob = require('glob');

  path = require('path');

  Promise = require('bluebird');

  MIM = require('mim');

  printLine = function(line) {
    return process.stdout.write(line + '\n');
  };

  printWarn = function(line) {
    return process.stderr.write(line + '\n');
  };

  SWITCHES = [['-i', '--input PATH', 'source folder'], ['-f', '--filename FILE', 'zip filename'], ['-b', '--bucket NAME', 'S3 bucket name'], ['-t', '--target NAME', "S3 key prefix (e.g. 'deploy/2015-04-01/'"], ['-n', '--nozip', 'disables zipping'], ['-a', '--archive', 'enables backup instead of overwriting'], ['-h', '--help', 'display this help message']];

  TMPDIR = 'tmp';

  BACKUP_PREFIX = 'backup';

  opts = {
    backup: false,
    zip: true,
    zipfile: TMPDIR + "/archive.zip",
    targetDir: void 0,
    bucket: void 0,
    source: void 0
  };

  s3 = AWS.s3();

  exports.run = function() {
    var missingArgs, parser, processFiles;
    parser = new optparse.OptionParser(SWITCHES);
    parser.on('help', function() {
      printLine(parser.toString());
      return process.exit();
    });
    parser.on('input', function(name, value) {
      return opts.source = value;
    });
    parser.on('filename', function(name, value) {
      return opts.zipfile = path.join(TMPDIR, value);
    });
    parser.on('bucket', function(name, value) {
      return opts.bucket = value;
    });
    parser.on('target', function(name, value) {
      return opts.targetDir = value;
    });
    parser.on('nozip', function() {
      return opts.zip = false;
    });
    parser.on('archive', function() {
      return opts.backup = true;
    });
    parser.parse(process.argv.slice(2));
    missingArgs = _.any(['bucket', 'source'], function(arg) {
      return _.isEmpty(opts[arg]);
    });
    if (missingArgs) {
      printLine('REQUIRED ARGUMENTS MISSING!');
      printLine('');
      printLine(parser.toString());
      process.exit();
    }
    if (!opts.targetDir) {
      opts.targetDir = '.';
    }
    if (!fs.existsSync(TMPDIR)) {
      fs.mkdirSync(TMPDIR);
    }
    processFiles = function() {
      var keyPrefix;
      if (opts.backup) {
        return backupFiles().then(uploadFiles);
      } else {
        keyPrefix = path.join(opts.targetDir, '/');
        return clearFiles(keyPrefix).then(uploadFiles);
      }
    };
    if (opts.zip) {
      return createZip().then(processFiles);
    } else {
      readFiles();
      return processFiles();
    }
  };

  createZip = function() {
    return new Promise(function(resolve, reject) {
      var archive, output;
      archive = archiver('zip');
      output = fs.createWriteStream(opts.zipfile);
      archive.pipe(output);
      archive.bulk([
        {
          src: ["**/*"],
          expand: true,
          cwd: opts.source,
          dot: true
        }
      ]);
      archive.on('finish', function() {
        return resolve();
      });
      archive.on('error', function() {
        return reject();
      });
      archive.finalize();
      opts.source = path.dirname(opts.zipfile);
      return opts.files = [opts.zipfile];
    });
  };

  readFiles = function() {
    return opts.files = glob.sync(path.join(opts.source, "**/*"), {
      expand: true,
      dot: true,
      nodir: true
    });
  };

  backupFiles = function() {
    return new Promise(function(resolve, reject) {
      var backupKeyPrefix, keyPrefix;
      keyPrefix = path.join(opts.targetDir, '/');
      backupKeyPrefix = path.join(BACKUP_PREFIX, opts.targetDir, '/');
      return clearFiles(backupKeyPrefix).then(function() {
        return readExistingFiles(keyPrefix).then(function(keys) {
          var i, key, len, promise, promises;
          if (_.isEmpty(keys)) {
            return resolve();
          }
          process.stdout.write('Backup');
          promises = [];
          for (i = 0, len = keys.length; i < len; i++) {
            key = keys[i];
            promise = s3.copyObjectPromised({
              Bucket: opts.bucket,
              CopySource: opts.bucket + "/" + key,
              Key: path.join(BACKUP_PREFIX, key),
              ACL: 'public-read'
            });
            promise.then(function() {
              return process.stdout.write('.');
            });
            promises.push(promise);
          }
          return Promise.all(promises).then(function() {
            process.stdout.write(' - done!\n');
            keyPrefix = path.join(opts.targetDir, '/');
            return clearFiles(keyPrefix).then(function() {
              return resolve();
            });
          });
        });
      });
    });
  };

  clearFiles = function(pathPrefix) {
    return new Promise(function(resolve, reject) {
      return readExistingFiles(pathPrefix).then(function(keys) {
        var objects;
        if (_.isEmpty(keys)) {
          return resolve();
        }
        process.stdout.write('Cleanup');
        objects = _.map(keys, function(key) {
          return {
            Key: key
          };
        });
        return s3.deleteObjectsPromised({
          Bucket: opts.bucket,
          Delete: {
            Objects: objects
          }
        }).then(function() {
          process.stdout.write(' - done!\n');
          return resolve();
        });
      });
    });
  };

  readExistingFiles = function(keyPrefix) {
    return new Promise(function(resolve, reject) {
      var onSuccess, promise;
      onSuccess = function(data) {
        var keys;
        keys = _.map(data['Contents'], 'Key');
        return resolve(keys);
      };
      return promise = s3.listObjectsPromised({
        Bucket: opts.bucket,
        Prefix: keyPrefix
      }).then(onSuccess);
    });
  };

  uploadFiles = function() {
    var file, i, len, mime, onError, onSuccess, params, promise, promises, ref, targetFile, targetKey;
    promises = [];
    process.stdout.write('Uploading');
    ref = opts.files;
    for (i = 0, len = ref.length; i < len; i++) {
      file = ref[i];
      targetFile = file.replace(path.join(opts.source, '/'), '');
      targetKey = path.join(opts.targetDir, targetFile);
      params = {
        Bucket: opts.bucket,
        Key: targetKey,
        Body: fs.createReadStream(file),
        ACL: 'public-read'
      };
      if (mime = MIM.getMIMEType(file)) {
        params['ContentType'] = MIM.getMIMEType(file);
      }
      promise = s3.putObjectPromised(params);
      onSuccess = function() {
        return process.stdout.write('.');
      };
      onError = function(error) {
        printLine(util.inspect(error));
        return process.exit();
      };
      promise.then(onSuccess, onError);
      promises.push(promise);
    }
    return Promise.all(promises).then(function() {
      return process.stdout.write(' - done!\n');
    });
  };

}).call(this);
