// Generated by CoffeeScript 1.10.0
(function() {
  var AWS, BACKUP_PREFIX, MIM, Promise, SWITCHES, TMPDIR, _, archiver, backupFiles, clearFiles, createZip, fs, glob, md5File, optparse, opts, path, printLine, printWarn, readExistingFiles, readFiles, retry, s3, uploadFiles, util;

  _ = require('lodash');

  archiver = require('archiver');

  AWS = require('aws-promised');

  optparse = require('optparse');

  util = require('util');

  fs = require('fs');

  glob = require('glob');

  path = require('path');

  Promise = require('bluebird');

  MIM = require('mim');

  md5File = require('md5-file');

  retry = require('bluebird-retry');

  printLine = function(line) {
    return process.stdout.write(line + '\n');
  };

  printWarn = function(line) {
    return process.stderr.write(line + '\n');
  };

  SWITCHES = [['-i', '--input PATH', 'source folder'], ['-f', '--filename FILE', 'zip filename'], ['-b', '--bucket NAME', 'S3 bucket name'], ['-t', '--target NAME', "S3 key prefix (e.g. 'deploy/2015-04-01/'"], ['-n', '--nozip', 'disables zipping'], ['-a', '--archive', 'enables backup instead of overwriting'], ['-h', '--help', 'display this help message']];

  TMPDIR = 'tmp';

  BACKUP_PREFIX = 'backup';

  opts = {
    backup: false,
    zip: true,
    zipfile: TMPDIR + "/archive.zip",
    targetDir: void 0,
    bucket: void 0,
    source: void 0
  };

  s3 = AWS.s3();

  exports.run = function() {
    var keyPrefix, missingArgs, parser;
    parser = new optparse.OptionParser(SWITCHES);
    parser.on('help', function() {
      printLine(parser.toString());
      return process.exit();
    });
    parser.on('input', function(name, value) {
      return opts.source = value;
    });
    parser.on('filename', function(name, value) {
      return opts.zipfile = path.join(TMPDIR, value);
    });
    parser.on('bucket', function(name, value) {
      return opts.bucket = value;
    });
    parser.on('target', function(name, value) {
      return opts.targetDir = value;
    });
    parser.on('nozip', function() {
      return opts.zip = false;
    });
    parser.on('archive', function() {
      return opts.backup = true;
    });
    parser.parse(process.argv.slice(2));
    missingArgs = _.any(['targetDir', 'bucket', 'source'], function(arg) {
      return _.isEmpty(opts[arg]);
    });
    if (missingArgs) {
      printLine('REQUIRED ARGUMENTS MISSING!');
      printLine('');
      printLine(parser.toString());
      process.exit();
    }
    if (!fs.existsSync(TMPDIR)) {
      fs.mkdirSync(TMPDIR);
    }
    if (opts.zip) {
      createZip();
    } else {
      readFiles();
    }
    if (opts.backup) {
      return backupFiles().then(uploadFiles);
    } else {
      keyPrefix = path.join(opts.targetDir, '/');
      return clearFiles(keyPrefix).then(uploadFiles);
    }
  };

  createZip = function() {
    var archive, output;
    archive = archiver('zip');
    output = fs.createWriteStream(opts.zipfile);
    archive.pipe(output);
    archive.bulk([
      {
        src: ["**/*"],
        expand: true,
        cwd: opts.source,
        dot: true
      }
    ]);
    archive.finalize();
    opts.source = path.dirname(opts.zipfile);
    return opts.files = [opts.zipfile];
  };

  readFiles = function() {
    return opts.files = glob.sync(path.join(opts.source, "**/*"), {
      expand: true,
      dot: true,
      nodir: true
    });
  };

  backupFiles = function() {
    return new Promise(function(resolve, reject) {
      var backupKeyPrefix, keyPrefix;
      keyPrefix = path.join(opts.targetDir, '/');
      backupKeyPrefix = path.join(BACKUP_PREFIX, opts.targetDir, '/');
      return clearFiles(backupKeyPrefix).then(function() {
        return readExistingFiles(keyPrefix).then(function(keys) {
          var i, key, len, promise, promises;
          if (_.isEmpty(keys)) {
            return resolve();
          }
          process.stdout.write('Backup');
          promises = [];
          for (i = 0, len = keys.length; i < len; i++) {
            key = keys[i];
            promise = s3.copyObjectPromised({
              Bucket: opts.bucket,
              CopySource: opts.bucket + "/" + key,
              Key: path.join(BACKUP_PREFIX, key),
              ACL: 'public-read'
            });
            promise.then(function() {
              return process.stdout.write('.');
            });
            promises.push(promise);
          }
          return Promise.all(promises).then(function() {
            process.stdout.write(' - done!\n');
            keyPrefix = path.join(opts.targetDir, '/');
            return clearFiles(keyPrefix).then(function() {
              return resolve();
            });
          });
        });
      });
    });
  };

  clearFiles = function(pathPrefix) {
    return new Promise(function(resolve, reject) {
      return readExistingFiles(pathPrefix).then(function(keys) {
        var objects;
        if (_.isEmpty(keys)) {
          return resolve();
        }
        process.stdout.write('Cleanup');
        objects = _.map(keys, function(key) {
          return {
            Key: key
          };
        });
        return s3.deleteObjectsPromised({
          Bucket: opts.bucket,
          Delete: {
            Objects: objects
          }
        }).then(function() {
          process.stdout.write(' - done!\n');
          return resolve();
        });
      });
    });
  };

  readExistingFiles = function(keyPrefix) {
    return new Promise(function(resolve, reject) {
      var onSuccess, promise;
      onSuccess = function(data) {
        var keys;
        keys = _.map(data['Contents'], 'Key');
        return resolve(keys);
      };
      return promise = s3.listObjectsPromised({
        Bucket: opts.bucket,
        Prefix: keyPrefix
      }).then(onSuccess);
    });
  };

  uploadFiles = function() {
    var doUpload, file, i, len, onError, onSuccess, promise, promises, ref;
    promises = [];
    process.stdout.write('Uploading');
    ref = opts.files;
    for (i = 0, len = ref.length; i < len; i++) {
      file = ref[i];
      doUpload = function(_file) {
        return function() {
          var md5, mime, params, targetFile, targetKey;
          targetFile = _file.replace(path.join(opts.source, '/'), '');
          targetKey = path.join(opts.targetDir, targetFile);
          md5 = md5File(_file);
          params = {
            Bucket: opts.bucket,
            Key: targetKey,
            Body: fs.createReadStream(_file),
            ACL: 'public-read'
          };
          if (mime = MIM.getMIMEType(_file)) {
            params['ContentType'] = mime;
          }
          return s3.putObjectPromised(params).then(function(data) {
            var etag;
            etag = data['ETag'].replace(/[^a-z0-9]/ig, '');
            if (md5 !== etag) {
              throw new Error("MD5 did not match for " + _file);
            }
          });
        };
      };
      promise = retry(doUpload(file), {
        max_tries: 3
      });
      onSuccess = function(data) {
        return process.stdout.write('.');
      };
      onError = function(error) {
        printLine(util.inspect(error));
        return process.exit();
      };
      promise.then(onSuccess, onError);
      promises.push(promise);
    }
    return Promise.all(promises).then(function() {
      return process.stdout.write(' - done!\n');
    });
  };

}).call(this);
